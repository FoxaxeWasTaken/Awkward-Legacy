server/src/converter/entity_extractor.py
    wife_id = None

    if husband:
        # Set gender for husband (first person in family line is typically male)
Copilot AI
18 hours ago
The comment 'first person in family line is typically male' is misleading. This code is inside the if husband: block, so it's setting gender because the person IS identified as a husband, not because of their position in the family line.

Suggested change
        # Set gender for husband (first person in family line is typically male)
        # Set gender for husband (identified as husband in family data)

server/src/converter/entity_extractor.py
            husband_id = husband_data.get("id")

    if wife:
        # Set gender for wife (second person in family line is typically female)
Copilot AI
18 hours ago
The comment 'second person in family line is typically female' is misleading. This code is inside the if wife: block, so it's setting gender because the person IS identified as a wife, not because of their position in the family line.

Suggested change
        # Set gender for wife (second person in family line is typically female)
        # Set gender for wife (person is identified as wife)

server/src/converter/json_normalizer.py
    persons = []

    for p in db_json.get("persons", []):
        person_id = str(p.get("id"))
Copilot AI
18 hours ago
Variable person_id is not used.

codescene-delta-analysis bot left a comment
Gates Failed
 Enforce critical code health rules (7 files with Bumpy Road Ahead, Deep, Nested Complexity)
 Enforce advisory code health rules (7 files with Overall Code Complexity, Complex Method, Complex Conditional)

Gates Passed
 4 Quality Gates Passed

See analysis details in CodeScene

Reason for failure

server/src/converter/json_normalizer.py
def _build_persons_list(db_json: dict) -> list:
    """Build persons list from database JSON."""
    persons = []

@codescene-delta-analysis codescene-delta-analysis bot 18 hours ago
❌ New issue: Complex Method
_build_persons_list has a cyclomatic complexity of 13, threshold = 9

server/src/converter/json_normalizer.py
def _build_persons_list(db_json: dict) -> list:
    """Build persons list from database JSON."""
    persons = []

@codescene-delta-analysis codescene-delta-analysis bot 18 hours ago
❌ New issue: Bumpy Road Ahead
_build_persons_list has 2 blocks with nested conditional logic. Any nesting of 2 or deeper is considered. Threshold is 2 blocks per function

server/src/converter/json_normalizer.py
def _build_persons_list(db_json: dict) -> list:
    """Build persons list from database JSON."""
    persons = []

@codescene-delta-analysis codescene-delta-analysis bot 18 hours ago
❌ New issue: Bumpy Road Ahead
_build_persons_list has 2 blocks with nested conditional logic. Any nesting of 2 or deeper is considered. Threshold is 2 blocks per function

server/src/endpoints/files.py
Comment on lines +304 to +468
def _filter_data_for_family_fixed(
    normalized_data: dict, raw_data: dict, family_id: str
) -> dict:
    """Filter data for family, fixing empty names issue."""
    family_id_str = str(family_id)

    # Find the target family in raw data
    target_family_raw = None
    for family in raw_data.get("families", []):
        if str(family.get("id")) == family_id_str:
            target_family_raw = family
            break

    if not target_family_raw:
        raise HTTPException(status_code=404, detail="Family not found")

    # Get all person IDs related to this family
    related_person_ids = set()

    # Add husband and wife IDs from raw data
    if target_family_raw.get("husband_id"):
        related_person_ids.add(str(target_family_raw["husband_id"]))
    if target_family_raw.get("wife_id"):
        related_person_ids.add(str(target_family_raw["wife_id"]))

    # Add children IDs
    for child in raw_data.get("children", []):
        if str(child.get("family_id")) == family_id_str:
            if child.get("child_id"):
                related_person_ids.add(str(child["child_id"]))

        # Filter persons to only include related ones (use raw data to get events)
        filtered_persons = []
        for person in raw_data.get("persons", []):
            if str(person.get("id")) in related_person_ids:
                # Manually attach events for this person
                person_events = []
                for event in raw_data.get("events", []):
                    if str(event.get("person_id")) == str(person.get("id")):
                        person_events.append(
                            {
                                "id": str(event.get("id")),
                                "type": event.get("type"),
                                "date": event.get("date"),
                                "place": event.get("place"),
                                "description": event.get("description"),
                                "person_id": (
                                    str(event.get("person_id"))
                                    if event.get("person_id")
                                    else None
                                ),
                                "family_id": (
                                    str(event.get("family_id"))
                                    if event.get("family_id")
                                    else None
                                ),
                            }
                        )

                person["events"] = person_events
                filtered_persons.append(person)

    # Build a proper family structure with fixed names
    husband_name = ""
    wife_name = ""

    # Get names from raw data
    for person in raw_data.get("persons", []):
        if str(person.get("id")) == str(target_family_raw.get("husband_id")):
            husband_name = (
                f"{person.get('first_name', '')} {person.get('last_name', '')}".strip()
            )
        elif str(person.get("id")) == str(target_family_raw.get("wife_id")):
            wife_name = (
                f"{person.get('first_name', '')} {person.get('last_name', '')}".strip()
            )

    # Build family header
    if husband_name and wife_name:
        family_header = f"{husband_name} + {wife_name}"
    elif husband_name:
        family_header = f"{husband_name} + Unknown"
    elif wife_name:
        family_header = f"Unknown + {wife_name}"
    else:
        family_header = "Unknown + Unknown"

    # Add marriage info
    if target_family_raw.get("marriage_date"):
        family_header += f" {target_family_raw['marriage_date']}"
    if target_family_raw.get("marriage_place"):
        family_header += f" #mp {target_family_raw['marriage_place']}"

    # Build children data
    children_data = []
    for child in raw_data.get("children", []):
        if str(child.get("family_id")) == family_id_str:
            child_person = None
            for person in raw_data.get("persons", []):
                if str(person.get("id")) == str(child.get("child_id")):
                    child_person = person
                    break

            if child_person:
                child_name = f"{child_person.get('first_name', '')} {child_person.get('last_name', '')}".strip()
                if child_name:
                    gender = (
                        "h"
                        if child_person.get("sex") == "M"
                        else "f" if child_person.get("sex") == "F" else "h"
                    )
                    children_data.append(
                        {
                            "raw": f"- {gender} {child_name}",
                            "gender": "male" if gender == "h" else "female",
                            "person": {"raw": child_name},
                        }
                    )

    # Build family events
    family_events = []
    for event in raw_data.get("events", []):
        if str(event.get("family_id")) == family_id_str:
            family_events.append(
                {
                    "type": event.get("type", ""),
                    "date": event.get("date", ""),
                    "place": event.get("place", ""),
                    "description": event.get("description", ""),
                }
            )

    # Build fixed family structure
    fixed_family = {
        "id": family_id_str,
        "raw_header": family_header,
        "husband": {"raw": husband_name} if husband_name else None,
        "wife": {"raw": wife_name} if wife_name else None,
        "sources": {},
        "events": family_events,
        "children": children_data,
        "marriage_date": target_family_raw.get("marriage_date"),
        "marriage_place": target_family_raw.get("marriage_place"),
        "notes": target_family_raw.get("notes"),
    }

    # Filter notes to only include related persons
    filtered_notes = []
    for person in filtered_persons:
        if person.get("notes"):
            person_name = (
                f"{person.get('first_name', '')} {person.get('last_name', '')}".strip()
            )
            if person_name:
                filtered_notes.append({"person": person_name, "text": person["notes"]})

    return {
        "persons": filtered_persons,
        "families": [fixed_family],
        "events": [],  # Events are included with persons
        "notes": filtered_notes,
        "extended_pages": {},
        "database_notes": None,
        "raw_header": {"gwplus": True, "encoding": "utf-8"},
    }
@codescene-delta-analysis codescene-delta-analysis bot 18 hours ago
❌ New issue: Complex Method
_filter_data_for_family_fixed has a cyclomatic complexity of 35, threshold = 9

server/src/endpoints/files.py
Comment on lines +277 to +279
        if (
            event.get("person_id") and str(event["person_id"]) in related_person_ids
        ) or (event.get("family_id") and str(event["family_id"]) == family_id_str):
@codescene-delta-analysis codescene-delta-analysis bot 18 hours ago
❌ New issue: Complex Conditional
_filter_data_for_family_raw has 1 complex conditionals with 3 branches, threshold = 2

server/src/endpoints/files.py
Comment on lines +304 to +468
def _filter_data_for_family_fixed(
    normalized_data: dict, raw_data: dict, family_id: str
) -> dict:
    """Filter data for family, fixing empty names issue."""
    family_id_str = str(family_id)

    # Find the target family in raw data
    target_family_raw = None
    for family in raw_data.get("families", []):
        if str(family.get("id")) == family_id_str:
            target_family_raw = family
            break

    if not target_family_raw:
        raise HTTPException(status_code=404, detail="Family not found")

    # Get all person IDs related to this family
    related_person_ids = set()

    # Add husband and wife IDs from raw data
    if target_family_raw.get("husband_id"):
        related_person_ids.add(str(target_family_raw["husband_id"]))
    if target_family_raw.get("wife_id"):
        related_person_ids.add(str(target_family_raw["wife_id"]))

    # Add children IDs
    for child in raw_data.get("children", []):
        if str(child.get("family_id")) == family_id_str:
            if child.get("child_id"):
                related_person_ids.add(str(child["child_id"]))

        # Filter persons to only include related ones (use raw data to get events)
        filtered_persons = []
        for person in raw_data.get("persons", []):
            if str(person.get("id")) in related_person_ids:
                # Manually attach events for this person
                person_events = []
                for event in raw_data.get("events", []):
                    if str(event.get("person_id")) == str(person.get("id")):
                        person_events.append(
                            {
                                "id": str(event.get("id")),
                                "type": event.get("type"),
                                "date": event.get("date"),
                                "place": event.get("place"),
                                "description": event.get("description"),
                                "person_id": (
                                    str(event.get("person_id"))
                                    if event.get("person_id")
                                    else None
                                ),
                                "family_id": (
                                    str(event.get("family_id"))
                                    if event.get("family_id")
                                    else None
                                ),
                            }
                        )

                person["events"] = person_events
                filtered_persons.append(person)

    # Build a proper family structure with fixed names
    husband_name = ""
    wife_name = ""

    # Get names from raw data
    for person in raw_data.get("persons", []):
        if str(person.get("id")) == str(target_family_raw.get("husband_id")):
            husband_name = (
                f"{person.get('first_name', '')} {person.get('last_name', '')}".strip()
            )
        elif str(person.get("id")) == str(target_family_raw.get("wife_id")):
            wife_name = (
                f"{person.get('first_name', '')} {person.get('last_name', '')}".strip()
            )

    # Build family header
    if husband_name and wife_name:
        family_header = f"{husband_name} + {wife_name}"
    elif husband_name:
        family_header = f"{husband_name} + Unknown"
    elif wife_name:
        family_header = f"Unknown + {wife_name}"
    else:
        family_header = "Unknown + Unknown"

    # Add marriage info
    if target_family_raw.get("marriage_date"):
        family_header += f" {target_family_raw['marriage_date']}"
    if target_family_raw.get("marriage_place"):
        family_header += f" #mp {target_family_raw['marriage_place']}"

    # Build children data
    children_data = []
    for child in raw_data.get("children", []):
        if str(child.get("family_id")) == family_id_str:
            child_person = None
            for person in raw_data.get("persons", []):
                if str(person.get("id")) == str(child.get("child_id")):
                    child_person = person
                    break

            if child_person:
                child_name = f"{child_person.get('first_name', '')} {child_person.get('last_name', '')}".strip()
                if child_name:
                    gender = (
                        "h"
                        if child_person.get("sex") == "M"
                        else "f" if child_person.get("sex") == "F" else "h"
                    )
                    children_data.append(
                        {
                            "raw": f"- {gender} {child_name}",
                            "gender": "male" if gender == "h" else "female",
                            "person": {"raw": child_name},
                        }
                    )

    # Build family events
    family_events = []
    for event in raw_data.get("events", []):
        if str(event.get("family_id")) == family_id_str:
            family_events.append(
                {
                    "type": event.get("type", ""),
                    "date": event.get("date", ""),
                    "place": event.get("place", ""),
                    "description": event.get("description", ""),
                }
            )

    # Build fixed family structure
    fixed_family = {
        "id": family_id_str,
        "raw_header": family_header,
        "husband": {"raw": husband_name} if husband_name else None,
        "wife": {"raw": wife_name} if wife_name else None,
        "sources": {},
        "events": family_events,
        "children": children_data,
        "marriage_date": target_family_raw.get("marriage_date"),
        "marriage_place": target_family_raw.get("marriage_place"),
        "notes": target_family_raw.get("notes"),
    }

    # Filter notes to only include related persons
    filtered_notes = []
    for person in filtered_persons:
        if person.get("notes"):
            person_name = (
                f"{person.get('first_name', '')} {person.get('last_name', '')}".strip()
            )
            if person_name:
                filtered_notes.append({"person": person_name, "text": person["notes"]})

    return {
        "persons": filtered_persons,
        "families": [fixed_family],
        "events": [],  # Events are included with persons
        "notes": filtered_notes,
        "extended_pages": {},
        "database_notes": None,
        "raw_header": {"gwplus": True, "encoding": "utf-8"},
    }
@codescene-delta-analysis codescene-delta-analysis bot 18 hours ago
❌ New issue: Bumpy Road Ahead
_filter_data_for_family_fixed has 8 blocks with nested conditional logic. Any nesting of 2 or deeper is considered. Threshold is 2 blocks per function

server/src/endpoints/files.py
Comment on lines +304 to +468
def _filter_data_for_family_fixed(
    normalized_data: dict, raw_data: dict, family_id: str
) -> dict:
    """Filter data for family, fixing empty names issue."""
    family_id_str = str(family_id)

    # Find the target family in raw data
    target_family_raw = None
    for family in raw_data.get("families", []):
        if str(family.get("id")) == family_id_str:
            target_family_raw = family
            break

    if not target_family_raw:
        raise HTTPException(status_code=404, detail="Family not found")

    # Get all person IDs related to this family
    related_person_ids = set()

    # Add husband and wife IDs from raw data
    if target_family_raw.get("husband_id"):
        related_person_ids.add(str(target_family_raw["husband_id"]))
    if target_family_raw.get("wife_id"):
        related_person_ids.add(str(target_family_raw["wife_id"]))

    # Add children IDs
    for child in raw_data.get("children", []):
        if str(child.get("family_id")) == family_id_str:
            if child.get("child_id"):
                related_person_ids.add(str(child["child_id"]))

        # Filter persons to only include related ones (use raw data to get events)
        filtered_persons = []
        for person in raw_data.get("persons", []):
            if str(person.get("id")) in related_person_ids:
                # Manually attach events for this person
                person_events = []
                for event in raw_data.get("events", []):
                    if str(event.get("person_id")) == str(person.get("id")):
                        person_events.append(
                            {
                                "id": str(event.get("id")),
                                "type": event.get("type"),
                                "date": event.get("date"),
                                "place": event.get("place"),
                                "description": event.get("description"),
                                "person_id": (
                                    str(event.get("person_id"))
                                    if event.get("person_id")
                                    else None
                                ),
                                "family_id": (
                                    str(event.get("family_id"))
                                    if event.get("family_id")
                                    else None
                                ),
                            }
                        )

                person["events"] = person_events
                filtered_persons.append(person)

    # Build a proper family structure with fixed names
    husband_name = ""
    wife_name = ""

    # Get names from raw data
    for person in raw_data.get("persons", []):
        if str(person.get("id")) == str(target_family_raw.get("husband_id")):
            husband_name = (
                f"{person.get('first_name', '')} {person.get('last_name', '')}".strip()
            )
        elif str(person.get("id")) == str(target_family_raw.get("wife_id")):
            wife_name = (
                f"{person.get('first_name', '')} {person.get('last_name', '')}".strip()
            )

    # Build family header
    if husband_name and wife_name:
        family_header = f"{husband_name} + {wife_name}"
    elif husband_name:
        family_header = f"{husband_name} + Unknown"
    elif wife_name:
        family_header = f"Unknown + {wife_name}"
    else:
        family_header = "Unknown + Unknown"

    # Add marriage info
    if target_family_raw.get("marriage_date"):
        family_header += f" {target_family_raw['marriage_date']}"
    if target_family_raw.get("marriage_place"):
        family_header += f" #mp {target_family_raw['marriage_place']}"

    # Build children data
    children_data = []
    for child in raw_data.get("children", []):
        if str(child.get("family_id")) == family_id_str:
            child_person = None
            for person in raw_data.get("persons", []):
                if str(person.get("id")) == str(child.get("child_id")):
                    child_person = person
                    break

            if child_person:
                child_name = f"{child_person.get('first_name', '')} {child_person.get('last_name', '')}".strip()
                if child_name:
                    gender = (
                        "h"
                        if child_person.get("sex") == "M"
                        else "f" if child_person.get("sex") == "F" else "h"
                    )
                    children_data.append(
                        {
                            "raw": f"- {gender} {child_name}",
                            "gender": "male" if gender == "h" else "female",
                            "person": {"raw": child_name},
                        }
                    )

    # Build family events
    family_events = []
    for event in raw_data.get("events", []):
        if str(event.get("family_id")) == family_id_str:
            family_events.append(
                {
                    "type": event.get("type", ""),
                    "date": event.get("date", ""),
                    "place": event.get("place", ""),
                    "description": event.get("description", ""),
                }
            )

    # Build fixed family structure
    fixed_family = {
        "id": family_id_str,
        "raw_header": family_header,
        "husband": {"raw": husband_name} if husband_name else None,
        "wife": {"raw": wife_name} if wife_name else None,
        "sources": {},
        "events": family_events,
        "children": children_data,
        "marriage_date": target_family_raw.get("marriage_date"),
        "marriage_place": target_family_raw.get("marriage_place"),
        "notes": target_family_raw.get("notes"),
    }

    # Filter notes to only include related persons
    filtered_notes = []
    for person in filtered_persons:
        if person.get("notes"):
            person_name = (
                f"{person.get('first_name', '')} {person.get('last_name', '')}".strip()
            )
            if person_name:
                filtered_notes.append({"person": person_name, "text": person["notes"]})

    return {
        "persons": filtered_persons,
        "families": [fixed_family],
        "events": [],  # Events are included with persons
        "notes": filtered_notes,
        "extended_pages": {},
        "database_notes": None,
        "raw_header": {"gwplus": True, "encoding": "utf-8"},
    }
@codescene-delta-analysis codescene-delta-analysis bot 18 hours ago
❌ New issue: Deep, Nested Complexity
_filter_data_for_family_fixed has a nested complexity depth of 5, threshold = 4

server/src/geneweb_converter.py
Comment on lines +89 to +103
    # Load persons with their events using selectinload for one-to-many relationships

    persons_statement = select(Person).options(selectinload(Person.events))
    persons = list(session.exec(persons_statement))

    # Load families with their relationships
    families_statement = select(Family).options(
        joinedload(Family.husband),
        joinedload(Family.wife),
        joinedload(Family.events),
        joinedload(Family.children).joinedload(Child.child),
    )
    families = list(session.exec(families_statement).unique())

    # Load all events separately for the events list
@codescene-delta-analysis codescene-delta-analysis bot 18 hours ago
❌ New issue: Complex Method
db_to_json has a cyclomatic complexity of 10, threshold = 9

server/src/geneweb_converter.py
Comment on lines +89 to +103
    # Load persons with their events using selectinload for one-to-many relationships

    persons_statement = select(Person).options(selectinload(Person.events))
    persons = list(session.exec(persons_statement))

    # Load families with their relationships
    families_statement = select(Family).options(
        joinedload(Family.husband),
        joinedload(Family.wife),
        joinedload(Family.events),
        joinedload(Family.children).joinedload(Child.child),
    )
    families = list(session.exec(families_statement).unique())

    # Load all events separately for the events list
@codescene-delta-analysis codescene-delta-analysis bot 18 hours ago
❌ New issue: Bumpy Road Ahead
db_to_json has 2 blocks with nested conditional logic. Any nesting of 2 or deeper is considered. Threshold is 2 blocks per function

server/src/serializer/event_serializer.py
Comment on lines +33 to +54
    else:
        # Build event line from individual fields
        event_type = event.get("type", "")
        date = event.get("date", "")
        place = event.get("place", "")
        description = event.get("description", "")

        # Convert date to string if it's a date object
        if hasattr(date, "strftime"):
            date = date.strftime("%Y-%m-%d")

        if event_type:
            event_parts = [event_type]
            if date:
                event_parts.append(str(date))
            if place:
                event_parts.append(f"#pl {place}")
            if description:
                event_parts.append(f"#desc {description}")

            event_line = " ".join(event_parts)
            lines.append(event_line)
@codescene-delta-analysis codescene-delta-analysis bot 18 hours ago
❌ New issue: Complex Method
serialize_event has a cyclomatic complexity of 10, threshold = 9

server/src/serializer/event_serializer.py
Comment on lines +33 to +54
    else:
        # Build event line from individual fields
        event_type = event.get("type", "")
        date = event.get("date", "")
        place = event.get("place", "")
        description = event.get("description", "")

        # Convert date to string if it's a date object
        if hasattr(date, "strftime"):
            date = date.strftime("%Y-%m-%d")

        if event_type:
            event_parts = [event_type]
            if date:
                event_parts.append(str(date))
            if place:
                event_parts.append(f"#pl {place}")
            if description:
                event_parts.append(f"#desc {description}")

            event_line = " ".join(event_parts)
            lines.append(event_line)
@codescene-delta-analysis codescene-delta-analysis bot 18 hours ago
❌ New issue: Bumpy Road Ahead
serialize_event has 3 blocks with nested conditional logic. Any nesting of 2 or deeper is considered. Threshold is 2 blocks per function

client/src/composables/useFamilyTree.ts
Comment on lines +27 to +31
      if (data.husband && (data.husband.first_name || data.husband.last_name)) {
        const husbandName = `${data.husband.first_name || ''} ${data.husband.last_name || ''}`.trim()
        if (husbandName) {
          parts.push(husbandName)
        }
@codescene-delta-analysis codescene-delta-analysis bot 18 hours ago
❌ New issue: Complex Conditional
useFamilyTree.loadFamilyData has 2 complex conditionals with 4 branches, threshold = 2

client/src/composables/useFamilyTree.ts
Comment on lines +27 to +31
      if (data.husband && (data.husband.first_name || data.husband.last_name)) {
        const husbandName = `${data.husband.first_name || ''} ${data.husband.last_name || ''}`.trim()
        if (husbandName) {
          parts.push(husbandName)
        }
@codescene-delta-analysis codescene-delta-analysis bot 18 hours ago
❌ New issue: Bumpy Road Ahead
useFamilyTree.loadFamilyData has 2 blocks with nested conditional logic. Any nesting of 2 or deeper is considered. Threshold is 2 blocks per function

client/src/composables/useFamilyTree.ts
      const parts = []
      if (data.husband) {
        parts.push(`${data.husband.first_name} ${data.husband.last_name}`)
      if (data.husband && (data.husband.first_name || data.husband.last_name)) {
@codescene-delta-analysis codescene-delta-analysis bot 18 hours ago
❌ New issue: Overall Code Complexity
This module has a mean cyclomatic complexity of 4.86 across 7 functions. The mean complexity threshold is 4

server/src/parsing/family_utils.py
Comment on lines +56 to +66
def _is_person_name_pair(current: str, next_word: str, words: list, idx: int) -> bool:
    """Check if two words form a person name pair."""
    current_valid = (',' not in current and
                    not (current.isupper() and len(current) <= 3) and
                    not current.startswith('#'))
    next_valid = (',' not in next_word and
                 not (next_word.isupper() and len(next_word) <= 3) and
                 not next_word.startswith('#'))
    has_tag_after = (idx + 2 < len(words) and words[idx + 2].startswith('#'))

    return current_valid and next_valid and has_tag_after
@codescene-delta-analysis codescene-delta-analysis bot 18 hours ago
❌ New issue: Complex Method
_is_person_name_pair has a cyclomatic complexity of 10, threshold = 9

server/src/parsing/family_utils.py
Comment on lines +22 to +39
def _extract_wife_from_complex_format(words: list) -> Optional[str]:
    """Extract wife name from complex family format with marriage place."""
    mp_found = False
    wife_start_idx = 0

    for i, word in enumerate(words):
        if word == '#mp':
            mp_found = True
            wife_start_idx = i + 1

            while wife_start_idx < len(words) - 1:
                current_word = words[wife_start_idx]
                next_word = words[wife_start_idx + 1]

                if _is_person_name_pair(current_word, next_word, words, wife_start_idx):
                    break
                wife_start_idx += 1
            break
@codescene-delta-analysis codescene-delta-analysis bot 18 hours ago
❌ New issue: Deep, Nested Complexity
_extract_wife_from_complex_format has a nested complexity depth of 4, threshold = 4

