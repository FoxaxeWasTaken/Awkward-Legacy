Declining Code Health
19 FINDINGS
(6 types in 6 files)
Files with highest declining Code Health findings are at the top.
Bumpy Road Ahead
server/src/converter/entity_extractor.py: _extract_spouses
Suppress finding
What lead to degradation?
_extract_spouses has 2 blocks with nested conditional logic. Any nesting of 2 or deeper is considered. Threshold is 2 blocks per function

Why does this problem occur?
A Bumpy Road is a function that contains multiple chunks of nested conditional logic inside the same function. The deeper the nesting and the more bumps, the lower the code health.

A bumpy code road represents a lack of encapsulation which becomes an obstacle to comprehension. In imperative languages there’s also an increased risk for feature entanglement, which leads to complex state management. CodeScene considers the following rules for the code health impact: 1) The deeper the nested conditional logic of each bump, the higher the tax on our working memory. 2) The more bumps inside a function, the more expensive it is to refactor as each bump represents a missing abstraction. 3) The larger each bump – that is, the more lines of code it spans – the harder it is to build up a mental model of the function. The nesting depth for what is considered a bump is levels of conditionals.

How to fix it?
Bumpy Road implementations indicate a lack of encapsulation. Check out the detailed description of the Bumpy Road code health issue.

A Bumpy Road often suggests that the function/method does too many things. The first refactoring step is to identify the different possible responsibilities of the function. Consider extracting those responsibilities into smaller, cohesive, and well-named functions. The EXTRACT FUNCTION refactoring is the primary response.

Bumpy Road Ahead
server/src/converter/entity_extractor.py: _extract_person_events
Suppress finding
What lead to degradation?
_extract_person_events has 2 blocks with nested conditional logic. Any nesting of 2 or deeper is considered. Threshold is 2 blocks per function

Why does this problem occur?
A Bumpy Road is a function that contains multiple chunks of nested conditional logic inside the same function. The deeper the nesting and the more bumps, the lower the code health.

A bumpy code road represents a lack of encapsulation which becomes an obstacle to comprehension. In imperative languages there’s also an increased risk for feature entanglement, which leads to complex state management. CodeScene considers the following rules for the code health impact: 1) The deeper the nested conditional logic of each bump, the higher the tax on our working memory. 2) The more bumps inside a function, the more expensive it is to refactor as each bump represents a missing abstraction. 3) The larger each bump – that is, the more lines of code it spans – the harder it is to build up a mental model of the function. The nesting depth for what is considered a bump is levels of conditionals.

How to fix it?
Bumpy Road implementations indicate a lack of encapsulation. Check out the detailed description of the Bumpy Road code health issue.

A Bumpy Road often suggests that the function/method does too many things. The first refactoring step is to identify the different possible responsibilities of the function. Consider extracting those responsibilities into smaller, cohesive, and well-named functions. The EXTRACT FUNCTION refactoring is the primary response.

Bumpy Road Ahead
server/src/converter/entity_extractor.py: _extract_person_notes
Suppress finding
What lead to degradation?
_extract_person_notes has 2 blocks with nested conditional logic. Any nesting of 2 or deeper is considered. Threshold is 2 blocks per function

Why does this problem occur?
A Bumpy Road is a function that contains multiple chunks of nested conditional logic inside the same function. The deeper the nesting and the more bumps, the lower the code health.

A bumpy code road represents a lack of encapsulation which becomes an obstacle to comprehension. In imperative languages there’s also an increased risk for feature entanglement, which leads to complex state management. CodeScene considers the following rules for the code health impact: 1) The deeper the nested conditional logic of each bump, the higher the tax on our working memory. 2) The more bumps inside a function, the more expensive it is to refactor as each bump represents a missing abstraction. 3) The larger each bump – that is, the more lines of code it spans – the harder it is to build up a mental model of the function. The nesting depth for what is considered a bump is levels of conditionals.

How to fix it?
Bumpy Road implementations indicate a lack of encapsulation. Check out the detailed description of the Bumpy Road code health issue.

A Bumpy Road often suggests that the function/method does too many things. The first refactoring step is to identify the different possible responsibilities of the function. Consider extracting those responsibilities into smaller, cohesive, and well-named functions. The EXTRACT FUNCTION refactoring is the primary response.

Bumpy Road Ahead
server/src/converter/entity_extractor.py: _find_person_by_name
Suppress finding
What lead to degradation?
_find_person_by_name has 2 blocks with nested conditional logic. Any nesting of 2 or deeper is considered. Threshold is 2 blocks per function

Why does this problem occur?
A Bumpy Road is a function that contains multiple chunks of nested conditional logic inside the same function. The deeper the nesting and the more bumps, the lower the code health.

A bumpy code road represents a lack of encapsulation which becomes an obstacle to comprehension. In imperative languages there’s also an increased risk for feature entanglement, which leads to complex state management. CodeScene considers the following rules for the code health impact: 1) The deeper the nested conditional logic of each bump, the higher the tax on our working memory. 2) The more bumps inside a function, the more expensive it is to refactor as each bump represents a missing abstraction. 3) The larger each bump – that is, the more lines of code it spans – the harder it is to build up a mental model of the function. The nesting depth for what is considered a bump is levels of conditionals.

How to fix it?
Bumpy Road implementations indicate a lack of encapsulation. Check out the detailed description of the Bumpy Road code health issue.

A Bumpy Road often suggests that the function/method does too many things. The first refactoring step is to identify the different possible responsibilities of the function. Consider extracting those responsibilities into smaller, cohesive, and well-named functions. The EXTRACT FUNCTION refactoring is the primary response.

Overall Code Complexity
server/src/converter/entity_extractor.py
Suppress finding
What lead to degradation?
This module has a mean cyclomatic complexity of 4.89 across 9 functions. The mean complexity threshold is 4

Why does this problem occur?
Overall Code Complexity is measured by the mean cyclomatic complexity across all functions in the file. The lower the number, the better.

Cyclomatic complexity is a function level metric that measures the number of logical branches (if-else, loops, etc.). Cyclomatic complexity is a rough complexity measure, but useful as a way of estimating the minimum number of unit tests you would need. As such, prefer functions with low cyclomatic complexity (2-3 branches).

How to fix it?
You address the overall cyclomatic complexity by a) modularizing the code, and b) abstract away the complexity. Let's look at some examples:

Modularizing the Code: Do an X-Ray and inspect the local hotspots. Are there any complex conditional expressions? If yes, then do a DECOMPOSE CONDITIONAL refactoring. Extract the conditional logic into a separate function and put a good name on that function. This clarifies the intent and makes the original function easier to read. Repeat until all complex conditional expressions have been simplified.

Complex Conditional
server/src/converter/json_normalizer.py: _build_notes_list
Suppress finding
What lead to degradation?
_build_notes_list has 1 complex conditionals with 2 branches, threshold = 2

Why does this problem occur?
A complex conditional is an expression inside a branch such as an if-statmeent which consists of multiple, logical operations. Example: if (x.started() && y.running()).Complex conditionals make the code even harder to read, and contribute to the Complex Method code smell. Encapsulate them.

How to fix it?
Apply the DECOMPOSE CONDITIONAL refactoring so that the complex conditional is encapsulated in a separate function with a good name that captures the business rule. Optionally, for simple expressions, introduce a new variable which holds the result of the complex conditional.

Helpful refactoring examples

SAMPLE
Complex Method
server/src/endpoints/files.py: _filter_data_for_family_raw
Suppress finding
What lead to degradation?
_filter_data_for_family_raw has a cyclomatic complexity of 22, threshold = 9

Why does this problem occur?
A Complex Method has a high cyclomatic complexity. The recommended threshold for the Python language is a cyclomatic complexity lower than 9.

How to fix it?
There are many reasons for Complex Method. Sometimes, another design approach is beneficial such as a) modeling state using an explicit state machine rather than conditionals, or b) using table lookup rather than long chains of logic. In other scenarios, the function can be split using EXTRACT FUNCTION. Just make sure you extract natural and cohesive functions. Complex Methods can also be addressed by identifying complex conditional expressions and then using the DECOMPOSE CONDITIONAL refactoring.

Helpful refactoring examples

SAMPLE
Complex Method
server/src/endpoints/files.py: _filter_data_for_family
Suppress finding
What lead to degradation?
_filter_data_for_family has a cyclomatic complexity of 19, threshold = 9

Why does this problem occur?
A Complex Method has a high cyclomatic complexity. The recommended threshold for the Python language is a cyclomatic complexity lower than 9.

How to fix it?
There are many reasons for Complex Method. Sometimes, another design approach is beneficial such as a) modeling state using an explicit state machine rather than conditionals, or b) using table lookup rather than long chains of logic. In other scenarios, the function can be split using EXTRACT FUNCTION. Just make sure you extract natural and cohesive functions. Complex Methods can also be addressed by identifying complex conditional expressions and then using the DECOMPOSE CONDITIONAL refactoring.

Helpful refactoring examples

SAMPLE
Complex Conditional
server/src/endpoints/files.py: _filter_data_for_family_raw
Suppress finding
What lead to degradation?
_filter_data_for_family_raw has 1 complex conditionals with 3 branches, threshold = 2

Why does this problem occur?
A complex conditional is an expression inside a branch such as an if-statmeent which consists of multiple, logical operations. Example: if (x.started() && y.running()).Complex conditionals make the code even harder to read, and contribute to the Complex Method code smell. Encapsulate them.

How to fix it?
Apply the DECOMPOSE CONDITIONAL refactoring so that the complex conditional is encapsulated in a separate function with a good name that captures the business rule. Optionally, for simple expressions, introduce a new variable which holds the result of the complex conditional.

Helpful refactoring examples

SAMPLE
Bumpy Road Ahead
server/src/endpoints/files.py: _filter_data_for_family
Suppress finding
What lead to degradation?
_filter_data_for_family has 6 blocks with nested conditional logic. Any nesting of 2 or deeper is considered. Threshold is 2 blocks per function

Why does this problem occur?
A Bumpy Road is a function that contains multiple chunks of nested conditional logic inside the same function. The deeper the nesting and the more bumps, the lower the code health.

A bumpy code road represents a lack of encapsulation which becomes an obstacle to comprehension. In imperative languages there’s also an increased risk for feature entanglement, which leads to complex state management. CodeScene considers the following rules for the code health impact: 1) The deeper the nested conditional logic of each bump, the higher the tax on our working memory. 2) The more bumps inside a function, the more expensive it is to refactor as each bump represents a missing abstraction. 3) The larger each bump – that is, the more lines of code it spans – the harder it is to build up a mental model of the function. The nesting depth for what is considered a bump is levels of conditionals.

How to fix it?


Bumpy Road Ahead
server/src/endpoints/files.py: _filter_data_for_family_raw
Suppress finding
What lead to degradation?
_filter_data_for_family_raw has 6 blocks with nested conditional logic. Any nesting of 2 or deeper is considered. Threshold is 2 blocks per function

Why does this problem occur?
A Bumpy Road is a function that contains multiple chunks of nested conditional logic inside the same function. The deeper the nesting and the more bumps, the lower the code health.

A bumpy code road represents a lack of encapsulation which becomes an obstacle to comprehension. In imperative languages there’s also an increased risk for feature entanglement, which leads to complex state management. CodeScene considers the following rules for the code health impact: 1) The deeper the nested conditional logic of each bump, the higher the tax on our working memory. 2) The more bumps inside a function, the more expensive it is to refactor as each bump represents a missing abstraction. 3) The larger each bump – that is, the more lines of code it spans – the harder it is to build up a mental model of the function. The nesting depth for what is considered a bump is levels of conditionals.

How to fix it?
Bumpy Road implementations indicate a lack of encapsulation. Check out the detailed description of the Bumpy Road code health issue.

A Bumpy Road often suggests that the function/method does too many things. The first refactoring step is to identify the different possible responsibilities of the function. Consider extracting those responsibilities into smaller, cohesive, and well-named functions. The EXTRACT FUNCTION refactoring is the primary response.

Overall Code Complexity
server/src/endpoints/files.py
Suppress finding
What lead to degradation?
This module has a mean cyclomatic complexity of 4.96 across 24 functions. The mean complexity threshold is 4

Why does this problem occur?
Overall Code Complexity is measured by the mean cyclomatic complexity across all functions in the file. The lower the number, the better.

Cyclomatic complexity is a function level metric that measures the number of logical branches (if-else, loops, etc.). Cyclomatic complexity is a rough complexity measure, but useful as a way of estimating the minimum number of unit tests you would need. As such, prefer functions with low cyclomatic complexity (2-3 branches).

How to fix it?
You address the overall cyclomatic complexity by a) modularizing the code, and b) abstract away the complexity. Let's look at some examples:

Modularizing the Code: Do an X-Ray and inspect the local hotspots. Are there any complex conditional expressions? If yes, then do a DECOMPOSE CONDITIONAL refactoring. Extract the conditional logic into a separate function and put a good name on that function. This clarifies the intent and makes the original function easier to read. Repeat until all complex conditional expressions have been simplified.

Deep, Nested Complexity
server/src/endpoints/files.py: _build_children_data
Suppress finding
What lead to degradation?
_build_children_data has a nested complexity depth of 5, threshold = 4

Why does this problem occur?
Deep nested logic means that you have control structures like if-statements or loops inside other control structures. Deep nested logic increases the cognitive load on the programmer reading the code. The human working memory has a maximum capacity of 3-4 items; beyond that threshold, we struggle with keeping things in our head. Consequently, deep nested logic has a strong correlation to defects and accounts for roughly 20% of all programming mistakes.

CodeScene measures the maximum nesting depth inside each function. The deeper the nesting, the lower the code health. The threshold for the Python language is 5 levels of nesting.

How to fix it?
Occassionally, it's possible to get rid of the nested logic by Replacing Conditionals with Guard Clauses.

Another viable strategy is to identify smaller building blocks inside the nested chunks of logic and extract those responsibilities into smaller, cohesive, and well-named functions. The EXTRACT FUNCTION refactoring explains the steps.

Excess Number of Function Arguments
server/src/endpoints/files.py: _build_fixed_family
Suppress finding
What lead to degradation?
_build_fixed_family has 7 arguments, max arguments = 4

Why does this problem occur?
Functions with many arguments indicate either a) low cohesion where the function has too many responsibilities, or b) a missing abstraction that encapsulates those arguments.

The threshold for the Python language is 4 function arguments.

How to fix it?
Start by investigating the responsibilities of the function. Make sure it doesn't do too many things, in which case it should be split into smaller and more cohesive functions. Consider the refactoring INTRODUCE PARAMETER OBJECT to encapsulate arguments that refer to the same logical concept.

Complex Method
server/src/geneweb_converter.py: db_to_json
Suppress finding
What lead to degradation?
db_to_json has a cyclomatic complexity of 10, threshold = 9

Why does this problem occur?
A Complex Method has a high cyclomatic complexity. The recommended threshold for the Python language is a cyclomatic complexity lower than 9.

How to fix it?
There are many reasons for Complex Method. Sometimes, another design approach is beneficial such as a) modeling state using an explicit state machine rather than conditionals, or b) using table lookup rather than long chains of logic. In other scenarios, the function can be split using EXTRACT FUNCTION. Just make sure you extract natural and cohesive functions. Complex Methods can also be addressed by identifying complex conditional expressions and then using the DECOMPOSE CONDITIONAL refactoring.

Helpful refactoring examples

SAMPLE
Bumpy Road Ahead
server/src/geneweb_converter.py: db_to_json
Suppress finding
What lead to degradation?
db_to_json has 2 blocks with nested conditional logic. Any nesting of 2 or deeper is considered. Threshold is 2 blocks per function

Why does this problem occur?
A Bumpy Road is a function that contains multiple chunks of nested conditional logic inside the same function. The deeper the nesting and the more bumps, the lower the code health.

A bumpy code road represents a lack of encapsulation which becomes an obstacle to comprehension. In imperative languages there’s also an increased risk for feature entanglement, which leads to complex state management. CodeScene considers the following rules for the code health impact: 1) The deeper the nested conditional logic of each bump, the higher the tax on our working memory. 2) The more bumps inside a function, the more expensive it is to refactor as each bump represents a missing abstraction. 3) The larger each bump – that is, the more lines of code it spans – the harder it is to build up a mental model of the function. The nesting depth for what is considered a bump is levels of conditionals.

How to fix it?
Bumpy Road implementations indicate a lack of encapsulation. Check out the detailed description of the Bumpy Road code health issue.

A Bumpy Road often suggests that the function/method does too many things. The first refactoring step is to identify the different possible responsibilities of the function. Consider extracting those responsibilities into smaller, cohesive, and well-named functions. The EXTRACT FUNCTION refactoring is the primary response.

Complex Conditional
client/src/composables/useFamilyTree.ts: _extractSpouseNames
Suppress finding
What lead to degradation?
_extractSpouseNames has 2 complex conditionals with 4 branches, threshold = 2

Why does this problem occur?
A complex conditional is an expression inside a branch such as an if-statmeent which consists of multiple, logical operations. Example: if (x.started() && y.running()).Complex conditionals make the code even harder to read, and contribute to the Complex Method code smell. Encapsulate them.

How to fix it?
Apply the DECOMPOSE CONDITIONAL refactoring so that the complex conditional is encapsulated in a separate function with a good name that captures the business rule. Optionally, for simple expressions, introduce a new variable which holds the result of the complex conditional.

Helpful refactoring examples

SAMPLE
Bumpy Road Ahead
client/src/composables/useFamilyTree.ts: _extractSpouseNames
Suppress finding
What lead to degradation?
_extractSpouseNames has 2 blocks with nested conditional logic. Any nesting of 2 or deeper is considered. Threshold is 2 blocks per function

Why does this problem occur?
A Bumpy Road is a function that contains multiple chunks of nested conditional logic inside the same function. The deeper the nesting and the more bumps, the lower the code health.

A bumpy code road represents a lack of encapsulation which becomes an obstacle to comprehension. In imperative languages there’s also an increased risk for feature entanglement, which leads to complex state management. CodeScene considers the following rules for the code health impact: 1) The deeper the nested conditional logic of each bump, the higher the tax on our working memory. 2) The more bumps inside a function, the more expensive it is to refactor as each bump represents a missing abstraction. 3) The larger each bump – that is, the more lines of code it spans – the harder it is to build up a mental model of the function. The nesting depth for what is considered a bump is levels of conditionals.

How to fix it?
Bumpy Road implementations indicate a lack of encapsulation. Check out the detailed description of the Bumpy Road code health issue.

A Bumpy Road often suggests that the function/method does too many things. The first refactoring step is to identify the different possible responsibilities of the function. Consider extracting those responsibilities into smaller, cohesive, and well-named functions. The EXTRACT FUNCTION refactoring is the primary response.

Deep, Nested Complexity
server/src/parsing/family_utils.py: _extract_wife_from_complex_format
Suppress finding
What lead to degradation?
_extract_wife_from_complex_format has a nested complexity depth of 4, threshold = 4

Why does this problem occur?
Deep nested logic means that you have control structures like if-statements or loops inside other control structures. Deep nested logic increases the cognitive load on the programmer reading the code. The human working memory has a maximum capacity of 3-4 items; beyond that threshold, we struggle with keeping things in our head. Consequently, deep nested logic has a strong correlation to defects and accounts for roughly 20% of all programming mistakes.

CodeScene measures the maximum nesting depth inside each function. The deeper the nesting, the lower the code health. The threshold for the Python language is 4 levels of nesting.

How to fix it?
Occassionally, it's possible to get rid of the nested logic by Replacing Conditionals with Guard Clauses.

Another viable strategy is to identify smaller building blocks inside the nested chunks of logic and extract those responsibilities into smaller, cohesive, and well-named functions. The EXTRACT FUNCTION refactoring explains the steps.

tests/test_person_endpoints.py ..................................        [100%]

=================================== FAILURES ===================================
__________ TestImportExportRoundtrip.test_roundtrip_test_family_file ___________

self = <tests.test_import_export_roundtrip.TestImportExportRoundtrip object at 0x7f3c2a12fc50>
test_db = <sqlmodel.orm.session.Session object at 0x7f3c28c57150>
test_family_gw_path = PosixPath('/app/docs/parsing/test_family.gw')

    def test_roundtrip_test_family_file(
        self, test_db: Session, test_family_gw_path: Path
    ):
        """Test complete round-trip with test_family.gw file."""
        # Step 1: Parse the original .gw file
        parser = GWParser(test_family_gw_path)
>       parsed_data = parser.parse()
                      ^^^^^^^^^^^^^^

tests/test_import_export_roundtrip.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/gw_parser.py:97: in parse
    self._read()
src/gw_parser.py:77: in _read
    self.lines = self.path.read_text(encoding="utf-8").splitlines()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/pathlib.py:1058: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/app/docs/parsing/test_family.gw'), mode = 'r', buffering = -1
encoding = 'utf-8', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return io.open(self, mode, buffering, encoding, errors, newline)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       FileNotFoundError: [Errno 2] No such file or directory: '/app/docs/parsing/test_family.gw'

/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/pathlib.py:1044: FileNotFoundError
______________ TestImportExportRoundtrip.test_gender_preservation ______________

self = <tests.test_import_export_roundtrip.TestImportExportRoundtrip object at 0x7f3c2a12c510>
test_db = <sqlmodel.orm.session.Session object at 0x7f3c2a1e5f50>
test_family_gw_path = PosixPath('/app/docs/parsing/test_family.gw')

    def test_gender_preservation(self, test_db: Session, test_family_gw_path: Path):
        """Test that gender information is preserved through round-trip."""
        # Parse and import
        parser = GWParser(test_family_gw_path)
>       parsed_data = parser.parse()
                      ^^^^^^^^^^^^^^

tests/test_import_export_roundtrip.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/gw_parser.py:97: in parse
    self._read()
src/gw_parser.py:77: in _read
    self.lines = self.path.read_text(encoding="utf-8").splitlines()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/pathlib.py:1058: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/app/docs/parsing/test_family.gw'), mode = 'r', buffering = -1
encoding = 'utf-8', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return io.open(self, mode, buffering, encoding, errors, newline)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       FileNotFoundError: [Errno 2] No such file or directory: '/app/docs/parsing/test_family.gw'

/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/pathlib.py:1044: FileNotFoundError
______________ TestImportExportRoundtrip.test_event_preservation _______________

self = <tests.test_import_export_roundtrip.TestImportExportRoundtrip object at 0x7f3c2a12d690>
test_db = <sqlmodel.orm.session.Session object at 0x7f3c28c15350>
test_family_gw_path = PosixPath('/app/docs/parsing/test_family.gw')

    def test_event_preservation(self, test_db: Session, test_family_gw_path: Path):
        """Test that events are preserved through round-trip."""
        # Parse and import
        parser = GWParser(test_family_gw_path)
>       parsed_data = parser.parse()
                      ^^^^^^^^^^^^^^

tests/test_import_export_roundtrip.py:232: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/gw_parser.py:97: in parse
    self._read()
src/gw_parser.py:77: in _read
    self.lines = self.path.read_text(encoding="utf-8").splitlines()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/pathlib.py:1058: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/app/docs/parsing/test_family.gw'), mode = 'r', buffering = -1
encoding = 'utf-8', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return io.open(self, mode, buffering, encoding, errors, newline)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       FileNotFoundError: [Errno 2] No such file or directory: '/app/docs/parsing/test_family.gw'

/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/pathlib.py:1044: FileNotFoundError
================================ tests coverage ================================
_______________ coverage: platform linux, python 3.11.13-final-0 _______________

Coverage XML written to file coverage.xml
=========================== short test summary info ============================
FAILED tests/test_import_export_roundtrip.py::TestImportExportRoundtrip::test_roundtrip_test_family_file - FileNotFoundError: [Errno 2] No such file or directory: '/app/docs/parsing/test_family.gw'
FAILED tests/test_import_export_roundtrip.py::TestImportExportRoundtrip::test_gender_preservation - FileNotFoundError: [Errno 2] No such file or directory: '/app/docs/parsing/test_family.gw'
FAILED tests/test_import_export_roundtrip.py::TestImportExportRoundtrip::test_event_preservation - FileNotFoundError: [Errno 2] No such file or directory: '/app/docs/parsing/test_family.gw'
======================== 3 failed, 535 passed in 22.26s ========================

would reformat /app/src/converter/json_normalizer.py
would reformat /app/src/parsing/family_utils.py
would reformat /app/src/endpoints/files.py

Oh no! 💥 💔 💥
3 files would be reformatted, 82 files would be left unchanged.

make: *** [Makefile:51: lint-server] Error 1

Geneweb Family Search App initialized

 ❯ src/__tests__/App.spec.ts (1 test | 1 failed) 18ms
   × App > renders properly 17ms
     → Cannot read properties of undefined (reading 'path')

⎯⎯⎯⎯⎯⎯⎯ Failed Tests 1 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  src/__tests__/App.spec.ts > App > renders properly
TypeError: Cannot read properties of undefined (reading 'path')
 ❯ Proxy._sfc_render src/App.vue:50:27
     48|         
     49|         <!-- Global Download Button - only show on home page -->
     50|         <div v-if="$route.path === '/'" class="global-download-section…
       |                           ^
     51|           <button 
     52|             @click="downloadAllData" 
 ❯ renderComponentRoot node_modules/@vue/runtime-core/dist/runtime-core.cjs.js:6532:16
 ❯ ReactiveEffect.componentUpdateFn [as fn] node_modules/@vue/runtime-core/dist/runtime-core.cjs.js:5332:46
 ❯ ReactiveEffect.run node_modules/@vue/reactivity/dist/reactivity.cjs.js:241:19
 ❯ setupRenderEffect node_modules/@vue/runtime-core/dist/runtime-core.cjs.js:5467:5
 ❯ mountComponent node_modules/@vue/runtime-core/dist/runtime-core.cjs.js:5241:7
 ❯ processComponent node_modules/@vue/runtime-core/dist/runtime-core.cjs.js:5193:9
 ❯ patch node_modules/@vue/runtime-core/dist/runtime-core.cjs.js:4720:11
 ❯ ReactiveEffect.componentUpdateFn [as fn] node_modules/@vue/runtime-core/dist/runtime-core.cjs.js:5339:11
 ❯ ReactiveEffect.run node_modules/@vue/reactivity/dist/reactivity.cjs.js:241:19

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[1/1]⎯


 Test Files  1 failed | 7 passed (8)
      Tests  1 failed | 126 passed (127)
   Start at  17:51:05
   Duration  3.86s (transform 1.14s, setup 0ms, collect 3.04s, tests 1.45s, environment 3.76s, prepare 851ms)


make: *** [Makefile:60: test-client] Error 1